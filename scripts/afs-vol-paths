#!/usr/bin/perl -w
=head1 NAME

afs-vol-paths - list full paths to volumes

=head1 SYNOPSIS

afs-vol-paths [options] [mounts ...]

  Options:
    --volume  volume name
    --rw      list paths which contain a -rw mount point
    --help    brief help message

=head1 DESCRIPTION

List the absolute paths to volumes from volscan output from
each fileserver.

Give a list of file names which contain the output from volscan for
each fileserver.  Use the following options to volscan:

    volscan \
      -find mounts \
      -output host partid vname vid vtype mtype mcell mvol path \
      -noheader

Specify - (dash) to read the volscan data from stdin.

=head1 OPTIONS

=over 8

=item B<--volume>

Volume name to resolve. Default is to list all volumes.

=item B<--rw>

Only list paths which contain at least one -rw mount.

=item B<--help>

Print a brief help message and exits.

=back

=cut

use Pod::Usage;
use Getopt::Long;

my %g_parents;

my $opt_volume = "";
my $opt_rw = 0;
my $opt_verbose = 0;
my $opt_help = 0;

GetOptions(
  "volume=s" => \$opt_volume,
  "rw" => \$opt_rw,
  "verbose" => \$opt_verbose,
  "help" => \$opt_help) || pod2usage(2);

if ($opt_help) {
    pod2usage(2);
}

my $mc = 0;
foreach my $mounts (@ARGV) {
    read_mounts($mounts);
    $mc++;
}
if ($mc == 0) {
    read_mounts("-");
}

if ($opt_volume) {
    print_paths($opt_volume);
}
else {
    foreach my $v (get_volumes()) {
        print_paths($v);
    }
}

sub read_mounts {
    my $mounts = shift;
    open(MOUNTS, "$mounts") || die "Cant open mount point data file: $mounts\n";
    while (<MOUNTS>) {
        chomp;
        my ($host, $partid, $volume, $vid, $vtype, $mtype, $mcell, $mvol, $path) = split;
        next if $vtype eq "BK"; # skip backups, for now
        next if $vtype eq "RO"; # skip ro, for now
        next if $mcell ne "--"; # skip cross cell
        my $rw = ($mtype eq '%' ? 1 : 0);
        unless ($g_parents{$mvol}) {
            $g_parents{$mvol} = [];
        }
        push(@{$g_parents{$mvol}}, {"path"=>$path, "volume"=>$volume, "vid"=>$vid, "rw"=>$rw});
    }
    close MOUNTS;
}

sub print_paths {
    my $volume = shift;
    my $paths = find_parent_paths([], [$volume], '', 0);
    if (scalar @{$paths} == 0) {
        #warn("no paths found for volume $volume\n");
    }
    else {
        #foreach (@{$paths}) {
        #    print "$volume:$_\n";
        #}
        print "$volume:", join(":",@{$paths}), "\n";
    }
}

sub find_parent_paths {
    my ($paths, $vols_ref, $path, $rwcount) = @_;
    my @vols = @{$vols_ref};

    my $volume = $vols[0];
    my $parents = $g_parents{$volume};
    if (!$parents) {
        if ($volume eq 'root.afs') {
            if ($rwcount || !$opt_rw) {
                push(@{$paths}, "/afs" . $path);
            }
        }
        else {
            warn("not mounted: ". join(" <- ", @vols) ."\n");
        }
    }
    else {
        foreach my $p (@{$parents}) {
            if (grep { $p->{volume} eq $_ } @vols) {
                warn("cycle detected: ". join(", ", @vols) ."\n");
            }
            else {
                $paths = find_parent_paths(
                    $paths,
                    [$p->{volume}, @vols],
                    $p->{path} . $path,
                    $rwcount + $p->{rw});
            }
        }
    }
    return $paths;
}

# Get list of volumes from vos listvldb.
sub get_volumes
{
    my @volumes = ();
    open(VOS, "vos listvldb |") or die "could not run vos listvld: $?";
    while (<VOS>) {
        next if /^VLDB entries/;
        next if /^Total entries/;
        if (/^(\S+)/) {
            push(@volumes, $1);
        }
    }
    close VOS;
    return @volumes;
}
